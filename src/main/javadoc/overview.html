<body>
<a href="http://github.com/lettuce-io/lettuce-core">Lettuce</a> is a scalable thread-safe Java
{@link io.lettuce.core.RedisClient RedisClient} providing
{@link io.lettuce.core.api.sync.RedisCommands synchronous},
{@link io.lettuce.core.api.async.RedisAsyncCommands asynchronous} and
{@link io.lettuce.core.api.reactive.RedisReactiveCommands reactive} APIs for Redis Standalone, PubSub,
Redis Sentinel and {@link io.lettuce.core.cluster.RedisClusterClient Redis Cluster}.

Multiple threads may share one connection if they avoid blocking and transactional
  operations such as <a href="http://redis.io/commands/blpop">BLPOP</a> and
  <a href="http://redis.io/commands/multi">MULTI</a>/<a href="http://redis.io/commands/exec">EXEC</a>.
  Multiple open connections are efficiently managed by the excellent
<a href="http://www.netty.io">netty</a> NIO framework.

  <p>
    Each redis command is implemented by one or more methods with names identical to the lowercase
    redis command name. Complex commands with multiple modifiers that change the result type include
    the CamelCased modifier as part of the command name, e.g.
    {@link io.lettuce.core.api.sync.RedisCommands#zrangebyscore zrangebyscore} and
    {@link io.lettuce.core.api.sync.RedisCommands#zrangebyscoreWithScores zrangebyscoreWithScores}.
  </p>

  <p>
    Redis connections are designed to be long-lived, and if the connection is lost will reconnect
    until {@code close()} is called. Pending commands that have not timed out will be (re)sent after
    successful reconnection.
  </p>

  <p>
    All connections inherit a default timeout from their {@link io.lettuce.core.RedisClient}
    and will throw a {@link io.lettuce.core.RedisException} when non-blocking commands fail
    to return a result before the timeout expires. The timeout defaults to 60 seconds and
    may be changed via {@link io.lettuce.core.RedisClient#setDefaultTimeout} or for
    each individual connection.
  </p>
</body>
